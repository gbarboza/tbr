/*
 * A token is generated upon getting clicking the bookmarklet and acts
 * as an alternative form of authentication.
 *
 * Tokens store the user id and have an expiration time of 30 seconds.
 *
 * Token looks like base64(userid|expiration|hmac(userid + expiration))
 *
 * HMACs ensure authenticity and integrity. I.e. tokens can't be forged.
 *
 * There's probably a library that does this, but I just needed something
 * simple and have written this code before.
 */

var crypto = require('crypto');
var key = 'SECRET';

exports.createToken = function(userid) {
    var EXPIRATION_DELTA = 30;
    var hmac = crypto.createHmac('sha1', key);
    var expiration = Math.round((new Date()).getTime() / 1000) +
        EXPIRATION_DELTA;
    var token;

    hmac.update(userid);
    hmac.update(expiration.toString());

    /* Cat and base64 encode token */
    token = new Buffer(userid + '|' + expiration + '|' + hmac.digest('hex'));
    token = token.toString('base64');

    return token;
};

exports.validateToken = function(id, token) {
    console.log('Checking token', id, token);
    var hmac = crypto.createHmac('sha1', key);
    var calculatedHMAC;
    var decoded = new Buffer(token, 'base64').toString('ascii');
    var splits = decoded.split('|');
    var exp = parseInt(splits[1]);
    var curTime = Math.round((new Date()).getTime() / 1000);

    hmac.update(splits[0]);
    hmac.update(splits[1]);
    calculatedHMAC = hmac.digest('hex');

    /* Check that token is generated by us */
    if (calculatedHMAC === splits[2]) {
        /* Check if token is still valid */
        if (exp >= curTime) {
            /* Check that user ids match */
            if (id === splits[0]) {
                return true;
            }
        }
    }

    console.log('Bad token was seen for', id, token);

    return false;
};
